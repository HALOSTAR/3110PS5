type 'a t = 'a array
(* basically a 2d array, but easier to handle *)
type 'a arrList = Arr of 'a array * 'a arrList | Empty

let multi_create (f:int -> unit) (n:int) : Thread.t array = 
  let a = Array.make n (Thread.self ()) in 
  for i=0 to n-1 do 
    a.(i) <- Thread.create f i;
  done;
  a
    
let multi_join (a:Thread.t array) : unit = 
  Array.iter Thread.join a

let length = Array.length

let empty () = [||]

let cons item arr = 
  let b = Array.make (1 + length arr) item in
  let f i = 
    if i = 0 then b.(i) <- item 
    else b.(i) <- (arr.(i-1)) in
  ignore(multi_create f (length b));
  b
  
let singleton item = 
  let a = empty () in
  cons item a
  
let tabulate f n =
  let m = Mutex.create () in
  let b = ref (empty ()) in
  let f2 i = (
    let v = f i in
    (if (length !b) = 0 then
      (Mutex.lock m; b := Array.make n v; Mutex.unlock m)
    else 
      (!b).(i) <- v) ) in
  multi_join (multi_create f2 n); 
  !b

let nth = 
  Array.get 

let split s i = 
  let res = (Array.make i s.(0), Array.make ((length s)-i) s.(0)) in
  let f j =  
    if j < i then (fst res).(j) <- s.(j)
    else (snd res).(j-i) <- s.(j) in 
  let a = multi_create f (length s) in
  multi_join a;
  res

(* Returns 'a * ('a array * 'a array)
   First element is the middle of the sequence
   second element are items to the left of middle
   third element are items to the right of the middle *)
let split_half s =
  let i = (length s) / 2 in
  let res = (Array.make i s.(0), Array.make ((length s)-i-1) s.(0)) in
  let f j =  
    if j < i then (fst res).(j) <- s.(j) 
    else if j = i then ()
    else (snd res).(j-i-1) <- s.(j) in 
  let a = multi_create f (length s) in
  multi_join a;
  (i, res)

let append s s2 = 
  let b = Array.make ((length s)+(length s2)) (nth s 0) in 
  let f i = 
    if i < (length s) then
      b.(i) <- s.(i)
    else 
      b.(i) <- s2.(i-(length s)) in 
  multi_join (multi_create f ((length s)+(length s2)));
  b

let map f s =
  let b = ref (empty()) in
  let m = Mutex.create () in
  let f2 i =
    let v = f s.(i) in
    if (length !b) = 0 then
      (Mutex.lock m; b := Array.make (length s) v; Mutex.unlock m;)
    else (!b).(i) <- v in 
  multi_join (multi_create f2 (length s));
  !b

let repeat x n = Array.make n x

let zip (s1,s2) = 
  (if (length s1) <> (length s2) then 
    failwith "Lengths of sequences must be equal"
  else ());
  let b = Array.make (length s1) ((nth s1 0),(nth s2 0)) in 
  let f i = 
    b.(i) <- ((nth s1 i),(nth s2 i)) in 
  multi_join (multi_create f (length s1));
  b

let half x =
  let a = (float_of_int x) /. 2. in
    if a < 1. then 0 else int_of_float (ceil a)

(* -1 inter node; i>0 marks index in arr *)
let filter f arr = 
  let newArray = map f arr in
  let count = ref Empty in
  let indices = ref Empty in
  let finalArray = ref (empty ()) in

  let createInitialTree i =
    if newArray.(i) then 
      (match (!count) with Arr (a,_) -> a.(i) <- (i,1))
    else () in

  let fillTree i = 
    print_string "fillTree i=";print_int i;print_string "\n";
    match (!count) with
        Arr (a, (Arr (a2,_))) -> 
          if (2*i+1) < (length a2) then 
            a.(i) <- (-1, (snd (a2.(2*i))) + (snd (a2.(2*i+1))))
          else
            a.(i) <- (-1, (snd (a2.(2*i)))) in

  let fillIndices i =
    print_string "fillIndices i=";print_int i;print_string "\n";
    let (Arr (c,_)) = (!count) in 
    match (!indices) with
        Arr (currLevel, (Arr (prevLevel,_))) -> 
          (let (low,high) = prevLevel.(i) in
           let currLeft = (low, high - (snd c.(i))) and
               currRight = (high - (snd c.(i)) + 1, high) in
             (currLevel.(2*i) <- currLeft;
              currLevel.(2*i+1) <- currRight)) in

  let fillFinal i =
    let ind = match (!indices) with Arr(a,_) -> (fst a.(i)) in
    (!finalArray).(ind) <- arr.(match (!count) with Arr(a,_) -> (fst a.(i))) in

  let rec reconstruct n = 
    if n < (length (!finalArray)) then
      (indices := Arr ((Array.make (2*n) (0,0)), (!indices));
       (match (!count) with Arr (a,b) -> count := b);
       multi_join (multi_create fillIndices n);
       reconstruct (2*n))
    else 
      (multi_join (multi_create fillFinal (length (!finalArray)))) in
     
  let rec spawner n =
    (* gets initial list of counts *)
    if n = (length arr) then 
      (count := Arr ((Array.make n (0,0)), Empty);
       multi_join (multi_create createInitialTree n);
       spawner (half 2))
    else if n = 0 then 
      ((match (!count) with 
           Arr (a,b) -> 
             (finalArray := Array.make (snd a.(0)) (nth arr 0);
              count := b));
        indices := Arr (Array.make 1 (0,(length (!finalArray))), Empty);
        reconstruct 1)
    else 
     (count := Arr ((Array.make n (0,0)), (!count) );
      multi_join (multi_create fillTree n);
      spawner (half n))
  in 
  spawner (length arr);
  (!finalArray)
      
    
    
  
    
  
